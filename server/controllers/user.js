// NOTE: Consider creating separate user and auth controllers once more extensive operations are implemented on the User
// (e.g. sign up, update profile, etc...)
const jwt = require('jsonwebtoken');
const twoFactor = require("node-2fa");
const User = require('../../models/UserSchema');
const MFAEnrolment = require('../../models/MFAEnrolment');
const STRINGS = require('../../locale/en').STRINGS;
const DEFAULT_SECRET = "not_so_secret";
const SECRET = (process.env.SECRET || DEFAULT_SECRET).trim();
const TOKEN_EXPIRY = (process.env.TOKEN_EXPIRY || "2h").trim();
const MFA_APP_NAME = "MernBlog"
if(SECRET === DEFAULT_SECRET){
    console.error("!!!!!!!!!!!!!   Production server SECRET is not set in env   !!!!!!!!!!!!! - controllers/user.js")
}

const logout = (req, res) => {
    if(res.statusCode === 401){
        res.status(401).send(STRINGS.LOGOUT_FAILURE);
    }else{
        // TODO:CLEANUP don't just clear the cookie, invalidate the token to prevent replay attack
        res.clearCookie("token", { httpOnly: true }).status(200).send("Successfully logged out!");
    }
}

const login = async (req, res) => {
    const { username, password } = req.body;
    const user = req.userFromMongo || await User.findOne({username});
    if(user){
        user.isCorrectPassword(password, function(err, same) {
            const _id = user._id;
            if (err) {
                res.status(500).json({message: STRINGS.SERVER_ERROR});
            } else if (!same) {
                res.status(401).json({message: STRINGS.LOGIN_FAILURE});
            } else {
                // Issue token
                const payload = { username, _id };
                const token = jwt.sign(payload, SECRET, {expiresIn: TOKEN_EXPIRY});
                res.status(200).cookie('token', token, { httpOnly: true }).send({message: STRINGS.LOGIN_SUCCESS});
            }
        });
    }else{
        res.status(401).json({message: STRINGS.LOGIN_FAILURE});
    }
}

const enrol2fa = async (req, res) => {
    let {password} = req.body;
    if(!password){
        res.status(401).json({message: STRINGS.PASSWORD_FAILURE});
        return;
    }

    const enrolment = await MFAEnrolment.findOne({user: req.user._id});
    if(enrolment){
        res.status(200).send({message: STRINGS.MFA_ALREADY_ENROLLED});
    }else{
        const user = await User.findById(req.user._id);
        // user must submit password to start enrolment
        user.isCorrectPassword(password, (err, pwValid) => {
            if (err) {
                res.status(500).json({message: STRINGS.SERVER_ERROR});
            } else if (!pwValid) {
                res.status(401).json({message: STRINGS.PASSWORD_FAILURE});
            } else {
                // secret is a json
                // for some reason, generated QR code is invalid in Authenticator extension in Chrome, the secret works though
                const secret = twoFactor.generateSecret({ name: MFA_APP_NAME, account: req.user.username });
                // ideally we should encrypt this secret and have the encryption key with frontend
                // so it can decrypt would protect from MITM
                // or set the secret in a cookie as encrypted jwt as source of truth
                res.status(200).send(secret);
            }
        });
    }
}

// Password should be once again verified, otherwise I can just steal someone's JWT,
// and call this endpoint with my own secret and code and then I have locked out that user.
const confirm2fa = async (req, res) => {
    const enrolment = await MFAEnrolment.findOne({user: req.user._id});
    if(enrolment){
        res.status(200).send({message: STRINGS.MFA_ALREADY_ENROLLED});
    }else{
        // we should validate the secret somehow as we can't trust that it is the one we originally created
        // or, we can additionally set the secret into a httponly cookie, encrypted with jwt.sign,
        // then only proceed if received secret + cookie secret match
        const {code, secret} = req.body;
        const match = twoFactor.verifyToken(secret, code);
        if(match && match.delta === 0){
            // also, note that if the user decides to send us a secret generated by themselves along with a code that works with that secret
            // we end up saving their secret instead of ours
            const enrolled = new MFAEnrolment({user: req.user._id, secret: secret});
            try{
                await enrolled.save();
                res.status(200).send({message: STRINGS.MFA_ENROL_SUCCESS});
            }catch(err){
                console.error(err);
                res.status(500).send({message: STRINGS.MFA_ENROL_FAILURE});
            }
        }else{
            res.status(401).send({message: STRINGS.MFA_INVALID_CODE})
        }
    }
}

const remove2fa = async (req, res) => {
    const {password} = req.body;
    const enrolment = await MFAEnrolment.findOne({user: req.user._id});
    if(enrolment){
        const user = await User.findById(req.user._id);
        user.isCorrectPassword(password, async function(err, pwValid) {
            if (err) {
                res.status(500).json({message: STRINGS.SERVER_ERROR});
            } else if (!pwValid) {
                res.status(401).json({message: STRINGS.PASSWORD_FAILURE});
            } else {
                await enrolment.remove();
                res.status(200).json({message: STRINGS.MFA_REMOVE_SUCCESS});
            }
        });
    }else{
        res.status(200).send({message: STRINGS.MFA_NOT_ENROLLED});
    }
}

const isAdmin = (req, res) => { res.send({ isAdmin: !!req.user }) }

const has2fa = async (req, res) => {
    const enrolment = await MFAEnrolment.findOne({user: req.user._id});
    res.status(200).send({ enabled: !!enrolment })
}

module.exports = {
    logout: logout,
    login: login,
    isAdmin: isAdmin,
    enrol2fa: enrol2fa,
    confirm2fa: confirm2fa,
    remove2fa: remove2fa,
    has2fa: has2fa
}